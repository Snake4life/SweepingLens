import fs = require("fs");
import { Provider } from "./provider";
import fileBackedObject from "./util/file-backed-object";
import { Event } from "./event";
import { DatabaseEvent } from "./database";
import SweepingLens from "./lens";

export default class ProviderContext<T> {
    public readonly data: T;

    constructor(private lens: SweepingLens, public readonly provider: Provider<T>) {
        const dataFile = `./data/providers/${provider.slug}.json`;
        if (!fs.existsSync(dataFile)) fs.writeFileSync(dataFile, "{}");

        this.data = fileBackedObject<T>(dataFile);
    }

    /**
     * Schedules a new interval for the current provider. This will ensure that errors from the
     * provider (both sync and async) are caught.
     */
    public setInterval(cb: () => any, time: number) {
        setInterval(async () => {
            try {
                const result = cb();
                result.then && await result;
            } catch (e) {
                this.log(`Error thrown executing interval: ${e.message}`);
            }
        }, time);
    }

    /**
     * Displays a log to stdout for the current provider.
     */
    public log(...args: any[]) {
        console.log(`[${new Date().toLocaleString()}] [${this.provider.slug}]: `, ...args);
    }

    /**
     * Acts as console.dir but prepends the current provider.
     */
    public dir(arg: any) {
        console.log(`[${new Date().toLocaleString()}] [${this.provider.slug}]:  <object>`);
        console.dir(arg);
    }

    /**
     * Notifies the central aggregation service that the current provider has
     * emitted a new event, which should be sent to the connected clients and persisted.
     */
    public async emit(event: Event) {
        if (await this.hasEvent(event.id)) throw new Error(`Duplicate event ${event.id} generated by provider ${this.provider.slug}`);

        const dbEntry = DatabaseEvent.fromEvent(this.provider, event);
        await dbEntry.save();

        this.lens.broadcast({
            type: "event",
            data: dbEntry.serialize()
        });
    }

    /**
     * Returns if the specified ID is already in the database. This method can be used to
     * query if a certain event needs to be emitted, or if it was already seen.
     * @param {string} id
     */
    public async hasEvent(id: string): Promise<boolean> {
        return await DatabaseEvent.where("provider", this.provider.slug).where("provider_id", id).count() > 0;
    }
}